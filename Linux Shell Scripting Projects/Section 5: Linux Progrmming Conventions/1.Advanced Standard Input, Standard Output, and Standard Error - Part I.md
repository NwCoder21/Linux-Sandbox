# Advanced Standard Input, Standard Output, and Standard Error - Part I

In this section, we will be covering the different types of input and output and how to 
redirect and control those types of input and output.

---

![image](https://user-images.githubusercontent.com/107522496/211286094-a3ba2bad-30ca-48c6-b3ce-a405d7ff570d.png)

We will call this script `luser-demo08.sh`.

---

![image](https://user-images.githubusercontent.com/107522496/211286518-3a23d712-9555-4e38-8ab5-315ec9023f8d.png)

Then we will add the Shebang to the start of the script and give a path to the bash executable and add a header to the script 
detailing what the main objective of this script it.

---

So far, the only type of input and output redirection that we have used has been in the 
form of a pipe. We have already written scripts that redirect the standard output from one command and send it 
as standard input into another by separating those commands with a pipe.

We have used this method to string together several commands in order to generate a random password. We also then used a pipe to send that random password to the `passwd` command. 

---

# Different Types of Input and Output

Let's first look at the different types of input and output. There are three types of I/O (Input and Output):

* Standard Input
* Standard Output
* Standard Error 

---

By default, Standard Input comes from the keyboard. For example, the `read` command accepts standard input and you use the `read` command to collect information from a user typing something in using their keyboard.

However, Standard Input does not have to come from a keyboard. An example of this is using pipes to take the output generated by one command and use that as the standard input for another command.

---

Moving on to Standard Ouput and Standard Error, by default, both of these are displayed to the screen.

Let's start the script by redirecting the standard output of a command into a file, and you can do that by using the `>` symbol.

> NOTE: ou'll often see Standard Out abbreviated as stdout.

---

# Redirecting STDOUT to a file

![image](https://user-images.githubusercontent.com/107522496/211289085-5352e575-ee80-415c-99ab-a29b60026b9f.png)

`FILE="/tmp/data"`: We're going to be using a file several times throughout this script, so I'm just going to assign that file name to a variable.

We wil call that variable `FILE` and then I'm going to say that that file is going to live in  
`/tmp/data` and we'll call the name of that file `data`.

`head -n1 /etc/passwd > ${FILE}`: We'll use the `head` command, with `-n1` which will output the very first line of a file, to look at the `/etc/passwd` file and we will send the Standard Output of this command into `{FILE}`.

---

Remember, by default, Standard Output is displayed to the screen, but because we are using the `>` symbol after the command, it is redirecting that output away from the screen and into the file we specified after the greater than sign.

Now let's see what happens when we actually execute this script.

---

![image](https://user-images.githubusercontent.com/107522496/211290760-40843566-eebb-47d9-a4bc-008e0a0f635c.png)

To do this, save your changes and make the script executable.

---

![image](https://user-images.githubusercontent.com/107522496/211290834-c225dbde-c19e-499f-9004-48febf2013f3.png)

As we can see, no output was generated when we ran this script. This is because, instead of directing the output to the screen, we chose to redirect the output to a file. 

Let's take a look at that file using `cat` ...

![image](https://user-images.githubusercontent.com/107522496/211291828-7708910f-c130-46fd-8771-92f7b63b8a53.png)

`root:x:0:0:root:/root:/bin/bash` seems to be the output of `head -n1 /etc/passwd`. We can confirm this on the command line by using `head -n1 /etc/passwd` ... 

![image](https://user-images.githubusercontent.com/107522496/211292293-3cc7696c-db24-4c14-9b58-bd03025c5b9c.png)

---

To clarify, this output redirection is not part of any one command. It works with all commands. So, for example let's try this with the `ID` commmand. Let's type `id -un > id_file`.

![image](https://user-images.githubusercontent.com/107522496/211292862-63a05670-bd84-4fb5-b001-04f6ef6922c1.png)

Nothing is outputted when we run `id -un > id_file`. However, if we then use the `cat` command, we can see the contents of the `id_file` contains the output of `id -un > id_file`. 

---

![image](https://user-images.githubusercontent.com/107522496/211293303-63b62c8c-204b-4474-8d3f-9bde8b21e074.png)

This is another example. Let's use `echo`. If we get the uid_file, sure enough, the output of the `echo` command is in the file that we redirected that output to.

---

REMEMBER: file permissions play a part in redirection too. So, if you try to redirect output into a file where you don't have write permissions, you're going to get an error. For example: 

![image](https://user-images.githubusercontent.com/107522496/211293736-dca27bad-220e-4d0d-8642-58895a526885.png)

---

# Redirecting Standard Input

Now that we know that `>` redirects Standard Output. Nowlet's use the less than symbol,`<`, to redirect Standard Input.

> Standard Input is often abbreviated as stdin.

---

![image](https://user-images.githubusercontent.com/107522496/211297737-d35cc5e3-86ea-436c-bd94-d66864f749d3.png)

`read LINE < ${FILE}`: Here, we will use the `read` command. After the input redirection, we will supply a filename, in this case, we'll just use the same file that we created with the _head_ command.

---

Previously, we used the _read_ command to accept Standard Input from a user. By using input redirection, we are now accepting standard input from a file.

The _read_ command reads one line of standard input when someone is typing at the keyboard and they hit enter. That represents one line of standard input.

When dealing with files, a new line character will cause _read_ to stop, so the variable `LINE` should contain the first line of the file. In this example, there is only one line in the file.

`echo "LINE contains: ${LINE}"`: Let's prove that by echoing it to the screen, we'll say that the line variable contains the contents of the line variable here and hit enter.

Let's save changes and execute the script. 

---

![image](https://user-images.githubusercontent.com/107522496/211300634-d6e63710-2752-4206-ac50-c740387d23a0.png)

![image](https://user-images.githubusercontent.com/107522496/211300568-e9b94d93-1d91-4655-8f90-e247135b6485.png)

Here, we used output redirection to send the first line of the `/etc/passwd` file into a file named `/tmp/data`. That file was then used as Standard Input to the _read_ command, which assigned the value to the `LINE` variable.

Finally, the `LINE` variable was displayed to Standard Output using the _echo_ command and that gives you what you see on your screen here.

---
 
Redirecting Standard Input from a file works with any command that accepts standard input. For example, the _passwd_
command. 

![image](https://user-images.githubusercontent.com/107522496/211301527-f3e3bd19-56aa-43be-aba3-c4fbd80da991.png)

Here, I have echoed the word 'secret' to a filewhich I have named password. When using _cat_ to see the contents of the password file, we can see that indeed it does contain the word 'secret'.

Now let's use that file as standard input to the _passwd_ command. So we need root privileges to do this.

![image](https://user-images.githubusercontent.com/107522496/211302246-57c251b1-de01-4e0f-8153-cb956555fb73.png)

We're going to use _sudo passwd_ with a _--stndin_ option and we need to supply a user. Here, we have the Einstein user set up on this system. So we're going to use that user. Then we're going to redirect in the standard input that lives in the file password.


So we're going to redirect the contents of the file name password as standard input into the _passwd_ command. 

It says the passwords were changed for the user Einstein. I can verify this by just switching users using and I'm going to enter s e c r e t and hit enter and sure enough it accepts the password. So that works.

---

So, the first method we learnt was with a pipe, but now you know that we can also use this input redirection with the less than sign, `<`.

And remember, the difference between those methods is that in a pipe, the Standard Input comes from the output of a command, whereas with this less than symbol, `<`, the standard input comes from a file. So that's the difference.

In other words, a pipe is used when you want to take output from a command as input into another command. But you can use this redirection when you want to redirect the contents of a file into a command.

---

NOTE: using a single greater than sign, `>,` to perform redirection creates a new file if that file doesn't exist, or it overwrites the contents of that file if it does exist. For example ...

![image](https://user-images.githubusercontent.com/107522496/211304494-dd6cee54-4387-4de9-8a72-40389f168dec.png)

At the moment, the password file contains the word `secret`. If we perform a redirection to that file, it will get overridden.

![image](https://user-images.githubusercontent.com/107522496/211304732-25c00f19-f0d4-450d-b3f9-f898df6fffa7.png)

So, here we have echoed the word `Hello` to the password file. Now when we use _cat_ to see what is in the password file now, we can see that secret has been emoved and now it contains the word Hello.

Now let's demonstrate this in our script.

---

# Redirecting STDOUT to a file, overwriting the file.

![image](https://user-images.githubusercontent.com/107522496/211305496-910a7fb6-3067-4619-8175-3ff610e0f60c.png)

`head -n3 /etc/passwd > ${FILE}`: So now we're going to take the first three lines of the `/etc/passwd` file and send that into FILE.

`cat ${FILE}`: here, we are showing the contents of the file named FILE.

Now, let's save and execute the script.

---

![image](https://user-images.githubusercontent.com/107522496/211306133-af69dc7d-58ef-4e33-916b-ee61218e671e.png)

![image](https://user-images.githubusercontent.com/107522496/211306098-b22252f5-8d50-44af-a08b-b68e87601098.png)

The first time we performed a redirection to the script, we took the first line of the `/etc/passwd` file and put it into a file. The next time we performed redirection to that file, we took the first three lines of the `/etc/passwd` file and wrote it to that file.

So here you can see that the contents of `/tmp/data` contains three lines, not four lines. It didn't append to it, rather, it over wrote the contents of that file.

---

# Using `>>` to Append Data to a File 

what if you don't want to override a file, but you want to add or append to it? In this case, use `>>` symbols.

---

![image](https://user-images.githubusercontent.com/107522496/211320161-7a06cad7-2890-4050-8bd3-3f374ec5294b.png)

For example, let's take a look at the password file. It contains the word Hello.

Now let's add another line to the file. We'll do this, by writing `echo "World"` , and then we'll use two greater than symbols. And by the way, they can't have a space between them, rather, they should be together.

![image](https://user-images.githubusercontent.com/107522496/211320550-d751b8ab-0ad8-4c00-915f-b25130b7be7e.png)

Now we see both lines, the original one and the latest line we added to it. 

--- 

Let's keep adding to this file by using one of our password generation techniques.

![image](https://user-images.githubusercontent.com/107522496/211320966-8bcfae0b-d972-4c1a-b1d7-ea7767425c33.png)

Now the file contains that extra data.

So here we use pipes and output redirection. Let's add this as an example of IO redirection to our script.

---

# Redirecting STDOUT to a File, Appending to the File

![image](https://user-images.githubusercontent.com/107522496/211321236-1f43092a-5221-4320-8134-257b02572ae6.png)

Let's save our changes and execute the script.

---

![image](https://user-images.githubusercontent.com/107522496/211321587-9aa1e6e7-6699-4389-b6b1-54ea34be0d40.png)

So originally the contents of `/temp/data` was one line. It was overwritten by three lines, and then we performed an append output redirection. And so now it has five lines, you can see the random numbers that we generated and appended to the file.

---

# Code 

![image](https://user-images.githubusercontent.com/107522496/211323844-2847c48b-2992-49ce-9639-de10661246b5.png)

---


```bash
#!/bin/bash

# This script demonstrates I/O redirection.

# Redirect STDOUT to a file.
FILE="/tmp/data"
head -n1 /etc/passwd > ${FILE}

# Redirect STDIN to a program.
read LINE < ${FILE}
echo "LINE contains: ${LINE}"

# Redirect STDOUT to a file, overwriting the file.
head -n3 /etc/passwd > ${FILE}
echo
echo "Contents of ${FILE}:"
cat ${FILE}

# Redirect STDOUT to a file, appending to the file.
echo "${RANDOM} ${RANDOM}" >> ${FILE}
echo "${RANDOM} ${RANDOM}" >> ${FILE}
echo
echo "Contents of ${FILE}:"
cat ${FILE}

```

---

 # Advanced Standard Input, Standard Output, and Standard Error - Part II
 
 
 # File Descriptors 
 
 Before we can cover redirecting standard error, we need to talk about file descriptors.
 
 A file descriptor is simply a number that represents an open file. Every new process starts with three open file descriptors.

They are: 

* File descriptor zero (FD 0 - STDIN), which is standard input 
* File Descriptor one (FD 1 - STDOUT), which is standard output
* and File Descriptor two (FD 2 - STDERR), which is standard error.

Linux represents practically everything.

A more accurate description of a file descriptor is that it's a way that a program interacts with files or to other resources that work like files. These other resources include devices such as keyboards, terminals and so on.

File Descriptors are like pointers to sources of data or places that data can be written things like keyboards, files, screens and so on.

---

Back to IO. So far in this lesson, we've been using the implicit way of redirecting input and output. For example, when we redirect standard input into a command, file descriptor zero is assumed.

![image](https://user-images.githubusercontent.com/107522496/212127020-eceebffb-6bb5-46bf-8a3e-8f649d4274fc.png)

Here we are looking at the contents of the `/etc/centos-release` file. Now let's use that file as standard input, to the _read_ command. 

---

![image](https://user-images.githubusercontent.com/107522496/212127511-f2ed9277-6eda-42ed-85e5-07beb7779ed9.png)

So we are going to read into the variable `x` the contents of `/etc/centos-release`. And then if we echo the contnts of X, we will see the contents of that file. From the above screenshot, we can see that the input redirection worked and this is the implicit way to do it.

---

![image](https://user-images.githubusercontent.com/107522496/212205139-d5026d11-7198-4d38-8446-12784e26b362.png)

If you want to be explicit, specify the file descriptor number right before the redirection operator. Here, we used `read X 0< /etc/centos-release` and it does the same thing as `read X 0 /etc/centos-release`. This is because if you don't supply a file descriptor then zero is assumed for standard

---

Notice that there is no space in `0<`. This is important to remember as if we leave a space between the `0` and `<`, then what you thought was a file descriptor number that you were specifying ends up being an argument to the command before the redirection operator. For example:

![image](https://user-images.githubusercontent.com/107522496/212205495-a1b3643f-9005-491a-863f-ab85ca55ce87.png)

We can see that if we leave a space an error will occur. 

---

Now let's be explicit with standard output redirection. So let's `echo "$UID" > test_file` ...

![image](https://user-images.githubusercontent.com/107522496/212205855-277b64b2-8eae-4418-9be6-83b689af1c52.png)

We can see our UID is 1000. This was the implicit way. If no file descriptor is given, then file descriptor one is assumed when using the `>` symbol.

`echo "$UID" > test_file` is the same this as `echo "$UID" 1> test_file` ...

![image](https://user-images.githubusercontent.com/107522496/212206098-53455750-8d3a-4198-abc7-9f17a1ee5a5a.png)

If we look at the contents of that file, it's the same thing because those two forms of redirection are the same. We can see we get the same results when using `>` or `1>`. 

---

Likewise, don't have a space between the `1` and the `>`. If we do ...

![image](https://user-images.githubusercontent.com/107522496/212206301-54573720-c848-45ac-94fd-a88ceaa2de4e.png)

We now get `1000 1` as the result which is in-correct. We get the `1` because one was treated as an argument to echo.

---

By convention, normal program output is sent to standard output while error messages are sent to standard error. When working at the command prompt, you may not even notice the difference because again, by default, they are both displayed to the screen.

--- 

Let's make a program generate an error. First, let's get some more information about the head command using `man head` ...

![image](https://user-images.githubusercontent.com/107522496/212213076-1da0247b-2fdb-4df4-8eff-f1ab6619eeb7.png)

From the synopsis, we see that `FILE` is in brackets and there's also three periods after that, which means we can supply multiple files to the `head` command.

We'll use `head -n1 /etc/passwd /etc/hosts` to read the first line if the `/etc/passwd` and `/etc/hosts` files ...

![image](https://user-images.githubusercontent.com/107522496/212213390-57fc33b0-6f57-4c0a-a57b-82dd29bbfd1e.png)

`==> /etc/passwd <==`: `head` shows use which file it's displaying what lines from .

First it shows one line from the `/etc/passwd` file and then one line from `/etc/hosts` file. 

---

Now let's use a file that doesn't exist ...

![image](https://user-images.githubusercontent.com/107522496/212213731-f592cc0c-6e30-40aa-85b5-57b295c60176.png)

There is both standard output and standard error generated here.

---

# Redirecting Standard Output to a File  

Let's redirect standard output to a file  ...

![image](https://user-images.githubusercontent.com/107522496/212213945-70fb5dcd-2afa-4d35-8f89-7eb862bb6c19.png)

Since standard error was not redirected, it was sent to the screen, and the normal standard output is saved into the `head.out` file. Let's see what the head.out file contains ...

![image](https://user-images.githubusercontent.com/107522496/212214095-3b0be7c4-a519-4092-a9f0-1fba143f2f56.png)

We can see it only contains the standard out information from the `head -n1 /etc/passwd /etc/hosts /fakefile > head.out` command and the error is outputted onto the screen.

---

# Redirecting Standard Error to a File 

Now let's redirect standard error into a file we will create called `head.error`. And the way to do that is to specify its file descriptor of two (`2>`)...

![image](https://user-images.githubusercontent.com/107522496/212214557-6f809b4d-c0cc-4a47-bbf1-71c813d29fe0.png)

We can look into the file using `cat`. We can see that the error was sent to `head.error`.

---

![image](https://user-images.githubusercontent.com/107522496/212214789-73db02f5-46a7-4940-9101-d99d87122534.png)

Let's just get rid of the files we just created.

---

# Redirecting Standard Output to One File and Standard Error to Another File  

Let's redirect standard output to one file while redirecting standard error to another.

---

We are using the command `head -n1 /etc/passwd /etc/hosts /fakefile > head.output 2> head.error`. `/etc/passwd /etc/hosts` files exist so there output will be sent to the `head.output` file. The file `/fakefile` does not exisit so will cause an error. The error will then be sent to the `head.error` file ...

![image](https://user-images.githubusercontent.com/107522496/212215572-19e9d817-ed72-4be2-9d55-2fa7023ceff7.png)

No outputto the screen just as we wanted. Let's look at the standard output because it's in the `head.output` file ...

![image](https://user-images.githubusercontent.com/107522496/212215716-fc071641-cace-4493-8196-c9ef967d1867.png)

---

And then let's look at the standard error because it's saved in this other file called `head.error` ...

![image](https://user-images.githubusercontent.com/107522496/212215812-f899a1d6-65b9-41ba-9ad0-2b860e115e6a.png)

We can see the error has been sent to the `head.error` file just as we wanted. 







Continue from 2;07

---



























