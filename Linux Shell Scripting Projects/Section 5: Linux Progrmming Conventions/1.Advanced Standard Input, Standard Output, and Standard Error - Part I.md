# Advanced Standard Input, Standard Output, and Standard Error - Part I

In this section, we will be covering the different types of input and output and how to 
redirect and control those types of input and output.

---

![image](https://user-images.githubusercontent.com/107522496/211286094-a3ba2bad-30ca-48c6-b3ce-a405d7ff570d.png)

We will call this script `luser-demo08.sh`.

---

![image](https://user-images.githubusercontent.com/107522496/211286518-3a23d712-9555-4e38-8ab5-315ec9023f8d.png)

Then we will add the Shebang to the start of the script and give a path to the bash executable and add a header to the script 
detailing what the main objective of this script it.

---

So far, the only type of input and output redirection that we have used has been in the 
form of a pipe. We have already written scripts that redirect the standard output from one command and send it 
as standard input into another by separating those commands with a pipe.

We have used this method to string together several commands in order to generate a random password. We also then used a pipe to send that random password to the `passwd` command. 

---

# Different Types of Input and Output

Let's first look at the different types of input and output. There are three types of I/O (Input and Output):

* Standard Input
* Standard Output
* Standard Error 

---

By default, Standard Input comes from the keyboard. For example, the `read` command accepts standard input and you use the `read` command to collect information from a user typing something in using their keyboard.

However, Standard Input does not have to come from a keyboard. An example of this is using pipes to take the output generated by one command and use that as the standard input for another command.

---

Moving on to Standard Ouput and Standard Error, by default, both of these are displayed to the screen.

Let's start the script by redirecting the standard output of a command into a file, and you can do that by using the `>` symbol.

> NOTE: ou'll often see Standard Out abbreviated as stdout.

---

# Redirecting STDOUT to a file

![image](https://user-images.githubusercontent.com/107522496/211289085-5352e575-ee80-415c-99ab-a29b60026b9f.png)

`FILE="/tmp/data"`: We're going to be using a file several times throughout this script, so I'm just going to assign that file name to a variable.

We wil call that variable `FILE` and then I'm going to say that that file is going to live in  
`/tmp/data` and we'll call the name of that file `data`.

`head -n1 /etc/passwd > ${FILE}`: We'll use the `head` command, with `-n1` which will output the very first line of a file, to look at the `/etc/passwd` file and we will send the Standard Output of this command into `{FILE}`.

---

Remember, by default, Standard Output is displayed to the screen, but because we are using the `>` symbol after the command, it is redirecting that output away from the screen and into the file we specified after the greater than sign.

Now let's see what happens when we actually execute this script.

---

![image](https://user-images.githubusercontent.com/107522496/211290760-40843566-eebb-47d9-a4bc-008e0a0f635c.png)

To do this, save your changes and make the script executable.

---

![image](https://user-images.githubusercontent.com/107522496/211290834-c225dbde-c19e-499f-9004-48febf2013f3.png)

As we can see, no output was generated when we ran this script. This is because, instead of directing the output to the screen, we chose to redirect the output to a file. 

Let's take a look at that file using `cat` ...

![image](https://user-images.githubusercontent.com/107522496/211291828-7708910f-c130-46fd-8771-92f7b63b8a53.png)

`root:x:0:0:root:/root:/bin/bash` seems to be the output of `head -n1 /etc/passwd`. We can confirm this on the command line by using `head -n1 /etc/passwd` ... 

![image](https://user-images.githubusercontent.com/107522496/211292293-3cc7696c-db24-4c14-9b58-bd03025c5b9c.png)

---

To clarify, this output redirection is not part of any one command. It works with all commands. So, for example let's try this with the `ID` commmand. Let's type `id -un > id_file`.

![image](https://user-images.githubusercontent.com/107522496/211292862-63a05670-bd84-4fb5-b001-04f6ef6922c1.png)

Nothing is outputted when we run `id -un > id_file`. However, if we then use the `cat` command, we can see the contents of the `id_file` contains the output of `id -un > id_file`. 

---

![image](https://user-images.githubusercontent.com/107522496/211293303-63b62c8c-204b-4474-8d3f-9bde8b21e074.png)

This is another example. Let's use `echo`. If we get the uid_file, sure enough, the output of the `echo` command is in the file that we redirected that output to.

---

REMEMBER: file permissions play a part in redirection too. So, if you try to redirect output into a file where you don't have write permissions, you're going to get an error. For example: 

![image](https://user-images.githubusercontent.com/107522496/211293736-dca27bad-220e-4d0d-8642-58895a526885.png)

---

# Redirecting Standard Input

Now that we know that `>` redirects Standard Output. Nowlet's use the less than symbol,`<`, to redirect Standard Input.

> Standard Input is often abbreviated as stdin.

---

![image](https://user-images.githubusercontent.com/107522496/211297737-d35cc5e3-86ea-436c-bd94-d66864f749d3.png)

`read LINE < ${FILE}`: Here, we will use the `read` command. After the input redirection, we will supply a filename, in this case, we'll just use the same file that we created with the _head_ command.

---

Previously, we used the _read_ command to accept Standard Input from a user. By using input redirection, we are now accepting standard input from a file.

The _read_ command reads one line of standard input when someone is typing at the keyboard and they hit enter. That represents one line of standard input.

When dealing with files, a new line character will cause _read_ to stop, so the variable `LINE` should contain the first line of the file. In this example, there is only one line in the file.

`echo "LINE contains: ${LINE}"`: Let's prove that by echoing it to the screen, we'll say that the line variable contains the contents of the line variable here and hit enter.

Let's save changes and execute the script. 

---

![image](https://user-images.githubusercontent.com/107522496/211300634-d6e63710-2752-4206-ac50-c740387d23a0.png)

![image](https://user-images.githubusercontent.com/107522496/211300568-e9b94d93-1d91-4655-8f90-e247135b6485.png)

Here, we used output redirection to send the first line of the `/etc/passwd` file into a file named `/tmp/data`. That file was then used as Standard Input to the _read_ command, which assigned the value to the `LINE` variable.

Finally, the `LINE` variable was displayed to Standard Output using the _echo_ command and that gives you what you see on your screen here.

---
 
Redirecting Standard Input from a file works with any command that accepts standard input. For example, the _passwd_
command. 

![image](https://user-images.githubusercontent.com/107522496/211301527-f3e3bd19-56aa-43be-aba3-c4fbd80da991.png)

Here, I have echoed the word 'secret' to a filewhich I have named password. When using _cat_ to see the contents of the password file, we can see that indeed it does contain the word 'secret'.

Now let's use that file as standard input to the _passwd_ command. So we need root privileges to do this.

![image](https://user-images.githubusercontent.com/107522496/211302246-57c251b1-de01-4e0f-8153-cb956555fb73.png)

We're going to use _sudo passwd_ with a _--stndin_ option and we need to supply a user. Here, we have the Einstein user set up on this system. So we're going to use that user. Then we're going to redirect in the standard input that lives in the file password.


So we're going to redirect the contents of the file name password as standard input into the _passwd_ command. 

It says the passwords were changed for the user Einstein. I can verify this by just switching users using and I'm going to enter s e c r e t and hit enter and sure enough it accepts the password. So that works.

---

So, the first method we learnt was with a pipe, but now you know that we can also use this input redirection with the less than sign, `<`.

And remember, the difference between those methods is that in a pipe, the Standard Input comes from the output of a command, whereas with this less than symbol, `<`, the standard input comes from a file. So that's the difference.

In other words, a pipe is used when you want to take output from a command as input into another command. But you can use this redirection when you want to redirect the contents of a file into a command.

---

NOTE: using a single greater than sign, `>,` to perform redirection creates a new file if that file doesn't exist, or it overwrites the contents of that file if it does exist. For example ...

![image](https://user-images.githubusercontent.com/107522496/211304494-dd6cee54-4387-4de9-8a72-40389f168dec.png)

At the moment, the password file contains the word `secret`. If we perform a redirection to that file, it will get overridden.

![image](https://user-images.githubusercontent.com/107522496/211304732-25c00f19-f0d4-450d-b3f9-f898df6fffa7.png)

So, here we have echoed the word `Hello` to the password file. Now when we use _cat_ to see what is in the password file now, we can see that secret has been emoved and now it contains the word Hello.

Now let's demonstrate this in our script.

---

# Redirecting STDOUT to a file, overwriting the file.

![image](https://user-images.githubusercontent.com/107522496/211305496-910a7fb6-3067-4619-8175-3ff610e0f60c.png)

`head -n3 /etc/passwd > ${FILE}`: So now we're going to take the first three lines of the `/etc/passwd` file and send that into FILE.

`cat ${FILE}`: here, we are showing the contents of the file named FILE.

Now, let's save and execute the script.

---

![image](https://user-images.githubusercontent.com/107522496/211306133-af69dc7d-58ef-4e33-916b-ee61218e671e.png)

![image](https://user-images.githubusercontent.com/107522496/211306098-b22252f5-8d50-44af-a08b-b68e87601098.png)

The first time we performed a redirection to the script, we took the first line of the `/etc/passwd` file and put it into a file. The next time we performed redirection to that file, we took the first three lines of the `/etc/passwd` file and wrote it to that file.

So here you can see that the contents of `/tmp/data` contains three lines, not four lines. It didn't append to it, rather, it over wrote the contents of that file.

---

# Using `>>` to Append Data to a File 

what if you don't want to override a file, but you want to add or append to it? In this case, use `>>` symbols.

---

![image](https://user-images.githubusercontent.com/107522496/211320161-7a06cad7-2890-4050-8bd3-3f374ec5294b.png)

For example, let's take a look at the password file. It contains the word Hello.

Now let's add another line to the file. We'll do this, by writing `echo "World"` , and then we'll use two greater than symbols. And by the way, they can't have a space between them, rather, they should be together.

![image](https://user-images.githubusercontent.com/107522496/211320550-d751b8ab-0ad8-4c00-915f-b25130b7be7e.png)

Now we see both lines, the original one and the latest line we added to it. 

--- 

Let's keep adding to this file by using one of our password generation techniques.

![image](https://user-images.githubusercontent.com/107522496/211320966-8bcfae0b-d972-4c1a-b1d7-ea7767425c33.png)

Now the file contains that extra data.

So here we use pipes and output redirection. Let's add this as an example of IO redirection to our script.

---

# Redirecting STDOUT to a File, Appending to the File

![image](https://user-images.githubusercontent.com/107522496/211321236-1f43092a-5221-4320-8134-257b02572ae6.png)

Let's save our changes and execute the script.

---

![image](https://user-images.githubusercontent.com/107522496/211321587-9aa1e6e7-6699-4389-b6b1-54ea34be0d40.png)

So originally the contents of `/temp/data` was one line. It was overwritten by three lines, and then we performed an append output redirection. And so now it has five lines, you can see the random numbers that we generated and appended to the file.

---

# Code 

![image](https://user-images.githubusercontent.com/107522496/211323844-2847c48b-2992-49ce-9639-de10661246b5.png)

---


```bash
#!/bin/bash

# This script demonstrates I/O redirection.

# Redirect STDOUT to a file.
FILE="/tmp/data"
head -n1 /etc/passwd > ${FILE}

# Redirect STDIN to a program.
read LINE < ${FILE}
echo "LINE contains: ${LINE}"

# Redirect STDOUT to a file, overwriting the file.
head -n3 /etc/passwd > ${FILE}
echo
echo "Contents of ${FILE}:"
cat ${FILE}

# Redirect STDOUT to a file, appending to the file.
echo "${RANDOM} ${RANDOM}" >> ${FILE}
echo "${RANDOM} ${RANDOM}" >> ${FILE}
echo
echo "Contents of ${FILE}:"
cat ${FILE}

```

---

 # Advanced Standard Input, Standard Output, and Standard Error - Part II
 
 
 # File Descriptors 
 
 Before we can cover redirecting standard error, we need to talk about file descriptors.
 
 A file descriptor is simply a number that represents an open file. Every new process starts with three open file descriptors.

They are: 

* File descriptor zero (FD 0 - STDIN), which is standard input 
* File Descriptor one (FD 1 - STDOUT), which is standard output
* and File Descriptor two (FD 2 - STDERR), which is standard error.

Linux represents practically everything.

A more accurate description of a file descriptor is that it's a way that a program interacts with files or to other resources that work like files. These other resources include devices such as keyboards, terminals and so on.

File Descriptors are like pointers to sources of data or places that data can be written things like keyboards, files, screens and so on.

---

Back to IO. So far in this lesson, we've been using the implicit way of redirecting input and output. For example, when we redirect standard input into a command, file descriptor zero is assumed.

![image](https://user-images.githubusercontent.com/107522496/212127020-eceebffb-6bb5-46bf-8a3e-8f649d4274fc.png)

Here we are looking at the contents of the `/etc/centos-release` file. Now let's use that file as standard input, to the _read_ command. 

---

![image](https://user-images.githubusercontent.com/107522496/212127511-f2ed9277-6eda-42ed-85e5-07beb7779ed9.png)

So we are going to read into the variable `x` the contents of `/etc/centos-release`. And then if we echo the contnts of X, we will see the contents of that file. From the above screenshot, we can see that the input redirection worked and this is the implicit way to do it.

---

![image](https://user-images.githubusercontent.com/107522496/212205139-d5026d11-7198-4d38-8446-12784e26b362.png)

If you want to be explicit, specify the file descriptor number right before the redirection operator. Here, we used `read X 0< /etc/centos-release` and it does the same thing as `read X 0 /etc/centos-release`. This is because if you don't supply a file descriptor then zero is assumed for standard

---

Notice that there is no space in `0<`. This is important to remember as if we leave a space between the `0` and `<`, then what you thought was a file descriptor number that you were specifying ends up being an argument to the command before the redirection operator. For example:

![image](https://user-images.githubusercontent.com/107522496/212205495-a1b3643f-9005-491a-863f-ab85ca55ce87.png)

We can see that if we leave a space an error will occur. 

---

Now let's be explicit with standard output redirection. So let's `echo "$UID" > test_file` ...

![image](https://user-images.githubusercontent.com/107522496/212205855-277b64b2-8eae-4418-9be6-83b689af1c52.png)

We can see our UID is 1000. This was the implicit way. If no file descriptor is given, then file descriptor one is assumed when using the `>` symbol.

`echo "$UID" > test_file` is the same this as `echo "$UID" 1> test_file` ...

![image](https://user-images.githubusercontent.com/107522496/212206098-53455750-8d3a-4198-abc7-9f17a1ee5a5a.png)

If we look at the contents of that file, it's the same thing because those two forms of redirection are the same. We can see we get the same results when using `>` or `1>`. 

---

Likewise, don't have a space between the `1` and the `>`. If we do ...

![image](https://user-images.githubusercontent.com/107522496/212206301-54573720-c848-45ac-94fd-a88ceaa2de4e.png)

We now get `1000 1` as the result which is in-correct. We get the `1` because one was treated as an argument to echo.

---

By convention, normal program output is sent to standard output while error messages are sent to standard error. When working at the command prompt, you may not even notice the difference because again, by default, they are both displayed to the screen.

--- 

Let's make a program generate an error. First, let's get some more information about the head command using `man head` ...

![image](https://user-images.githubusercontent.com/107522496/212213076-1da0247b-2fdb-4df4-8eff-f1ab6619eeb7.png)

From the synopsis, we see that `FILE` is in brackets and there's also three periods after that, which means we can supply multiple files to the `head` command.

We'll use `head -n1 /etc/passwd /etc/hosts` to read the first line if the `/etc/passwd` and `/etc/hosts` files ...

![image](https://user-images.githubusercontent.com/107522496/212213390-57fc33b0-6f57-4c0a-a57b-82dd29bbfd1e.png)

`==> /etc/passwd <==`: `head` shows use which file it's displaying what lines from .

First it shows one line from the `/etc/passwd` file and then one line from `/etc/hosts` file. 

---

Now let's use a file that doesn't exist ...

![image](https://user-images.githubusercontent.com/107522496/212213731-f592cc0c-6e30-40aa-85b5-57b295c60176.png)

There is both standard output and standard error generated here.

---

# Redirecting Standard Output to a File  

Let's redirect standard output to a file  ...

![image](https://user-images.githubusercontent.com/107522496/212213945-70fb5dcd-2afa-4d35-8f89-7eb862bb6c19.png)

Since standard error was not redirected, it was sent to the screen, and the normal standard output is saved into the `head.out` file. Let's see what the head.out file contains ...

![image](https://user-images.githubusercontent.com/107522496/212214095-3b0be7c4-a519-4092-a9f0-1fba143f2f56.png)

We can see it only contains the standard out information from the `head -n1 /etc/passwd /etc/hosts /fakefile > head.out` command and the error is outputted onto the screen.

---

# Redirecting Standard Error to a File 

Now let's redirect standard error into a file we will create called `head.error`. And the way to do that is to specify its file descriptor of two (`2>`)...

![image](https://user-images.githubusercontent.com/107522496/212214557-6f809b4d-c0cc-4a47-bbf1-71c813d29fe0.png)

We can look into the file using `cat`. We can see that the error was sent to `head.error`.

---

![image](https://user-images.githubusercontent.com/107522496/212214789-73db02f5-46a7-4940-9101-d99d87122534.png)

Let's just get rid of the files we just created.

---

# Redirecting Standard Output to One File and Standard Error to Another File  

Let's redirect standard output to one file while redirecting standard error to another.

---

We are using the command `head -n1 /etc/passwd /etc/hosts /fakefile > head.output 2> head.error`. `/etc/passwd /etc/hosts` files exist so there output will be sent to the `head.output` file. The file `/fakefile` does not exisit so will cause an error. The error will then be sent to the `head.error` file ...

![image](https://user-images.githubusercontent.com/107522496/212215572-19e9d817-ed72-4be2-9d55-2fa7023ceff7.png)

No outputto the screen just as we wanted. Let's look at the standard output because it's in the `head.output` file ...

![image](https://user-images.githubusercontent.com/107522496/212215716-fc071641-cace-4493-8196-c9ef967d1867.png)

---

And then let's look at the standard error because it's saved in this other file called `head.error` ...

![image](https://user-images.githubusercontent.com/107522496/212215812-f899a1d6-65b9-41ba-9ad0-2b860e115e6a.png)

We can see the error has been sent to the `head.error` file just as we wanted. 

---

# 2>> - Appending Standard Error 

We most likley would like to append the standard output to a file. `2>` overwrites the contents of a file, whereas `2>>` appends standard output to a file. Using the above command, we can adjust it to ... 

```ymal
 `head -n1 /etc/passwd /etc/hosts /fakefile > head.output 2>> head.error`
 ```
 
![image](https://user-images.githubusercontent.com/107522496/212284305-d0731133-80fb-4b73-8414-c29f5db9ab28.png)

Now we can see, using `2>>`, we can append data instead of overwriting it when using standard error. 

---

#  How to send Standard Output and Standard Error to the Same Place?

What if we want to send standard output and standard error to the same place? There a couple of ways to do this. There is an older syntax and then there is a the new syntax to do this.
 
 Te older method is ...

```yaml
head -n1 /etc/passwd /etc/hosts /fakefile > head.both 2>&1
```

![image](https://user-images.githubusercontent.com/107522496/212292714-7b7ecbf0-9969-4749-9689-7b885e807e4c.png)

Here, we are sending the standard ouput and standard error to one file called `head.out`.

> So if we cat `head.both`, you will see the standard output and the standard error both in that one file. This is because `> head.both` is redirecting standard output to head.both. `2>` means redirect standard error to `head.both`. All output will be written to head both

---

Spacing is important as well. Do not use the space after the redirection operator (`2>` )and the `&1`.

---

New syntax was added to Bash to redirect both standard input and standard output. That syntax is `&>` and then a path to a file.

```yaml
head -n1 /etc/passwd /etc/hosts /fakefile &> head.both
```

![image](https://user-images.githubusercontent.com/107522496/212301702-5e9ae144-0b92-45d1-9767-7b70624a49a8.png)

The above is an example of using `&>` to redirect standard output and standard error.  

---

# Using `&>>` to Append Standard Output and Standard Error to a File 


Can use `&>>` to append standard output and standard error to a file. 

![image](https://user-images.githubusercontent.com/107522496/212302709-4b46795c-e228-4a79-94e4-f152d93f404c.png)

---

If you think back to when you first started using pipes, you learned that a pipe takes the standard output of one command and uses it as standard input for another command. This means that standard error doesn't flow through the pipe. Let's see an example ofthis but first let's look at the `cat` man page.

---

![image](https://user-images.githubusercontent.com/107522496/212305724-8d25d745-0722-4c1c-b792-075a430b696e.png)

`-n`, `--number`: number all output lines

![image](https://user-images.githubusercontent.com/107522496/212306092-c94e37b4-8768-4317-aa65-344eb2856909.png)

If we go back to the `head -n1 /etc/passwd /etc/hosts /fakefile` command without any redirection, it looks like it specifies six lines. 

```yaml
==> /etc/passwd <==
root:x:0:0:root:/root:/bin/bash

==> /etc/hosts <==
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
head: cannot open ‘/fakefile’ for reading: No such file or directory
```


However, if we pipe this to `cat` and use the `-n` option, `cat` only counts five lines. This is because first standard error is displayed to the screen because it was not passed through the pipe. The standard output of the `head` command was passed through the pipe as the input to the `cat` command. The `cat` command numbered each file it received a standard input.

---

It's important to know that about pipes, that you're only getting the standard output going through the pipe.

If you want to force all the output of a command through the pipe, then you need to append the standard error to the standard input.

So one way we can do this is specify a file descriptor of two, which is for standard error, and then redirect that into ampersand one, which represents file descriptor one, which in turn represents standard output. So now that standard error is going to standard output and all the standard output goes through the pipe, then cat should count all of our lines.

---

![image](https://user-images.githubusercontent.com/107522496/212308227-bf05ae4f-3b93-439e-8812-d130d841065e.png)

Now we can see it counts all six of our lines. 

Now there's a shorthand for this. It's `|&`. it combines the standard error and standard output into one and then passes that through the pipe so we get the same result.

![image](https://user-images.githubusercontent.com/107522496/212309189-eb999e9c-9a09-45aa-97e9-eda69267a715.png)

We can see that we get the same result. 

---

Let's get back to our script and really do a mini recap of what we've been talking about and let's document it in our script so we have something to look back to if we want to later.

Now we will edit our file and we're just going to be really repeating some of the examples above, but this time using file descriptors.

---

# Redirecting STDIN to a Program, Using File Descriptor 0

![image](https://user-images.githubusercontent.com/107522496/212310586-d6924a44-7752-4b85-9340-d0901cdde676.png)

---

# Redirecting STDOUT to a File Using File Descriptor 1, Overwriting the File.

![image](https://user-images.githubusercontent.com/107522496/212310929-57d22253-d770-4e81-bb2a-cea462af8179.png)

---

Let's save script and test it so far.

---

![image](https://user-images.githubusercontent.com/107522496/212311562-75a187c6-8dd5-4f56-98f3-3751dc28d944.png)

![image](https://user-images.githubusercontent.com/107522496/212311105-88878307-cad7-4f85-b89e-563d02b1ea4f.png)

More or less, we get a repeat of what happens at the top of the script. We get `LINE` containing the first line of `data` and we get the contents of `/tmp/data` containing three lines as well. Even though we use the explicit form of redirection by supplying file descriptors. So again, it works the exact same way, implicit or explicit.

---

# Redirecting STDERR to a file using File Descriptor 2.

![image](https://user-images.githubusercontent.com/107522496/212313114-9010ed0a-b4c7-4f96-8b96-ccc47fa0c47f.png)

Standard error is a File Descriptor 2.

`ERR_FILE="/tmp/data.err"`: So we're going to use this `ERR_FILE` a couple of times. Let's create a new variable as well.

`/fakefile`: We'll give this file something that's going to generate an error, a file that doesn't exist.
`2> ${ERR_FILE}`: We'll redirect that error message into the `ERR_FILE`.

Then save and test the script now. 

---

![image](https://user-images.githubusercontent.com/107522496/212313069-cfa437b6-71e8-4f87-85ba-287206e1f104.png)

---

![image](https://user-images.githubusercontent.com/107522496/212313281-bc774783-a17a-4295-aaa9-cc4aa954d258.png)

Then using `cat /tmp/data.err` we can see that the error message that was generated by the `head` command that we redirected into that file. So that's doing exactly what we specified.

---

Now let's redirect the standard out and standard error to a file.


---

# Redirecting STDOUT and STDERR to a file.

![image](https://user-images.githubusercontent.com/107522496/212313802-23f2848a-ecef-44e2-823d-53083470509d.png)

`:head -n3 /etc/passwd /fakefile &> ${FILE}`: here, we are using the new syntatx, `&>` symbol to send standard output and standard error to a file. 

Let's then save and test the script.

---

![image](https://user-images.githubusercontent.com/107522496/212315138-f42f38a8-e99a-441a-a82a-0d8b5bbadb35.png)

![image](https://user-images.githubusercontent.com/107522496/212316048-47c4d9ee-7710-484e-84c2-c1bffb70fe40.png)

We can see that everything is displayed to our screen there. So the standard output as well as standard error are both combined.

---

# Redirecting STDOUT and STDERR Through a Pipe.

![image](https://user-images.githubusercontent.com/107522496/212316700-3b17f7f9-bd6a-4e47-8fd0-3353c7edf2f6.png)

`head -n3 /etc/passwd /fakefile |& cat -n`: Here, we are using the new syntaxt of `|&`. The `-n` option will number the standard input that cat receives.

Let's then save and test the script.

---

![image](https://user-images.githubusercontent.com/107522496/212316639-b14d0440-e499-4405-93e5-2df61fc59045.png)

And sure enough, the error message of cannot open `/fakefilefile` gets passed through the pipe to `cat` and gets numbered. 

So we've appended standard error to standard output. Let's do the opposite, which is to append standard output to standard error.

Go over 18:26 till 19:57

---

# Send output to STDERR

![image](https://user-images.githubusercontent.com/107522496/212317371-e92f4e73-cecd-4e77-9d78-61a2e4111436.png)

Let's then save and test the script.

---

![image](https://user-images.githubusercontent.com/107522496/212318406-944c5487-1910-4a7f-9b7d-cc3f1f4fb2e7.png)


Now let's execute our script and redirect standard error to a file that we'll call `err` using:

```yaml
./luser-demo08.sh 2> err
```

This is what we get ...

![image](https://user-images.githubusercontent.com/107522496/212318864-930f26f6-52f2-4ac1-a7a8-7492176374cc.png)

We can see if we now `cat err`, the standard error generated by our script is in that file.

---

# NULL DEVICE - /dev/null

The null device is a special file that throws away whatever is sent to it. so if you don't want to see output on your screen, and you don't want to save that output to a file either, then redirect that output to the null device which is located at `/dev/null`.

---

First, let's recap what `head -n1 /etc/passwd /etc/hosts /fakefile` outputs ...

![image](https://user-images.githubusercontent.com/107522496/212319744-d4243963-86bd-4c43-8076-1fed17b0d988.png)

---

Now let's discard the standard output, so we'll just send the standard output to `/dev/null`. So all we're left with is standard error.

![image](https://user-images.githubusercontent.com/107522496/212319940-964f9a37-afa7-4a4d-9d4e-84b2bf8e567b.png)

This only shows the error.

---

We can also just throw away the standard error to `/dev/null` by using a `2>` and directing the standard output to the screen ...

![image](https://user-images.githubusercontent.com/107522496/212320288-e947d576-ac16-4e12-b996-c7327bd4c3e2.png)

---

Now let's throw away all the output generated by the command and we know how to do that because we can use `&>` symobols to combine standard output and standard error and we'll redirect that to `/dev/null`.

![image](https://user-images.githubusercontent.com/107522496/212321466-1cefa5f7-61a7-437f-ace3-79bc15e5a66c.png)

So no output is generated.

---

You might wonder when you would want to do such a thing. Well, here is the use case. If you're executing a command in your script and you don't want the user running the script to see that output, then send it to `/dev/null`.

And remember, if you need to know that a command succeeded or not, simply check its exit status. You don't need the output to determine if it succeeded or failed.

![image](https://user-images.githubusercontent.com/107522496/212321706-d7ce955b-78de-4a1c-91a2-4efc509cff91.png)

In the above example, using `echo "${?}"`, we can see that something went wrong.

---

![image](https://user-images.githubusercontent.com/107522496/212323001-4793ab75-c7ed-4ba6-bad5-cedc5b041c0e.png)

If we make the command succeed, for example, take away that `/fakefile` that doesn't exist and then we check the return status, we get an exit status zero. So we know that the command succeeded.

Now let's finish up our little script here by adding these examples.

---






Continue from 7:50

---



























