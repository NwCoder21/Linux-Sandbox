# Advanced Standard Input, Standard Output, and Standard Error - Part I

In this section, we will be covering the different types of input and output and how to 
redirect and control those types of input and output.

---

![image](https://user-images.githubusercontent.com/107522496/211286094-a3ba2bad-30ca-48c6-b3ce-a405d7ff570d.png)

We will call this script `luser-demo08.sh`.

---

![image](https://user-images.githubusercontent.com/107522496/211286518-3a23d712-9555-4e38-8ab5-315ec9023f8d.png)

Then we will add the Shebang to the start of the script and give a path to the bash executable and add a header to the script 
detailing what the main objective of this script it.

---

So far, the only type of input and output redirection that we have used has been in the 
form of a pipe. We have already written scripts that redirect the standard output from one command and send it 
as standard input into another by separating those commands with a pipe.

We have used this method to string together several commands in order to generate a random password. We also then used a pipe to send that random password to the `passwd` command. 

---

# Different Types of Input and Output

Let's first look at the different types of input and output. There are three types of I/O (Input and Output):

* Standard Input
* Standard Output
* Standard Error 

---

By default, Standard Input comes from the keyboard. For example, the `read` command accepts standard input and you use the `read` command to collect information from a user typing something in using their keyboard.

However, Standard Input does not have to come from a keyboard. An example of this is using pipes to take the output generated by one command and use that as the standard input for another command.

---

Moving on to Standard Ouput and Standard Error, by default, both of these are displayed to the screen.

Let's start the script by redirecting the standard output of a command into a file, and you can do that by using the `>` symbol.

> NOTE: ou'll often see Standard Out abbreviated as stdout.

---

# Redirecting STDOUT to a file

![image](https://user-images.githubusercontent.com/107522496/211289085-5352e575-ee80-415c-99ab-a29b60026b9f.png)

`FILE="/tmp/data"`: We're going to be using a file several times throughout this script, so I'm just going to assign that file name to a variable.

We wil call that variable `FILE` and then I'm going to say that that file is going to live in  
`/tmp/data` and we'll call the name of that file `data`.

`head -n1 /etc/passwd > ${FILE}`: We'll use the `head` command, with `-n1` which will output the very first line of a file, to look at the `/etc/passwd` file and we will send the Standard Output of this command into `{FILE}`.

---

Remember, by default, Standard Output is displayed to the screen, but because we are using the `>` symbol after the command, it is redirecting that output away from the screen and into the file we specified after the greater than sign.

Now let's see what happens when we actually execute this script.

---

![image](https://user-images.githubusercontent.com/107522496/211290760-40843566-eebb-47d9-a4bc-008e0a0f635c.png)

To do this, save your changes and make the script executable.

---

![image](https://user-images.githubusercontent.com/107522496/211290834-c225dbde-c19e-499f-9004-48febf2013f3.png)

As we can see, no output was generated when we ran this script. This is because, instead of directing the output to the screen, we chose to redirect the output to a file. 

Let's take a look at that file using `cat` ...

![image](https://user-images.githubusercontent.com/107522496/211291828-7708910f-c130-46fd-8771-92f7b63b8a53.png)

`root:x:0:0:root:/root:/bin/bash` seems to be the output of `head -n1 /etc/passwd`. We can confirm this on the command line by using `head -n1 /etc/passwd` ... 

![image](https://user-images.githubusercontent.com/107522496/211292293-3cc7696c-db24-4c14-9b58-bd03025c5b9c.png)

---

To clarify, this output redirection is not part of any one command. It works with all commands. So, for example let's try this with the `ID` commmand. Let's type `id -un > id_file`.

![image](https://user-images.githubusercontent.com/107522496/211292862-63a05670-bd84-4fb5-b001-04f6ef6922c1.png)

Nothing is outputted when we run `id -un > id_file`. However, if we then use the `cat` command, we can see the contents of the `id_file` contains the output of `id -un > id_file`. 

---

![image](https://user-images.githubusercontent.com/107522496/211293303-63b62c8c-204b-4474-8d3f-9bde8b21e074.png)

This is another example. Let's use `echo`. If we get the uid_file, sure enough, the output of the `echo` command is in the file that we redirected that output to.

---

REMEMBER: file permissions play a part in redirection too. So, if you try to redirect output into a file where you don't have write permissions, you're going to get an error. For example: 

![image](https://user-images.githubusercontent.com/107522496/211293736-dca27bad-220e-4d0d-8642-58895a526885.png)

---

# Redirecting Standard Input

Now that we know that `>` redirects Standard Output. Nowlet's use the less than symbol,`<`, to redirect Standard Input.

> Standard Input is often abbreviated as stdin.

---

![image](https://user-images.githubusercontent.com/107522496/211297737-d35cc5e3-86ea-436c-bd94-d66864f749d3.png)

`read LINE < ${FILE}`: Here, we will use the `read` command. After the input redirection, we will supply a filename, in this case, we'll just use the same file that we created with the _head_ command.

---

Previously, we used the _read_ command to accept Standard Input from a user. By using input redirection, we are now accepting standard input from a file.

The _read_ command reads one line of standard input when someone is typing at the keyboard and they hit enter. That represents one line of standard input.

When dealing with files, a new line character will cause _read_ to stop, so the variable `LINE` should contain the first line of the file. In this example, there is only one line in the file.

`echo "LINE contains: ${LINE}"`: Let's prove that by echoing it to the screen, we'll say that the line variable contains the contents of the line variable here and hit enter.

Let's save changes and execute the script. 

































