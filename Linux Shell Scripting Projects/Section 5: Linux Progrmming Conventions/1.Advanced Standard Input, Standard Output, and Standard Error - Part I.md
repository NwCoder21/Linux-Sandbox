# Advanced Standard Input, Standard Output, and Standard Error - Part I

In this section, we will be covering the different types of input and output and how to 
redirect and control those types of input and output.

---

![image](https://user-images.githubusercontent.com/107522496/211286094-a3ba2bad-30ca-48c6-b3ce-a405d7ff570d.png)

We will call this script `luser-demo08.sh`.

---

![image](https://user-images.githubusercontent.com/107522496/211286518-3a23d712-9555-4e38-8ab5-315ec9023f8d.png)

Then we will add the Shebang to the start of the script and give a path to the bash executable and add a header to the script 
detailing what the main objective of this script it.

---

So far, the only type of input and output redirection that we have used has been in the 
form of a pipe. We have already written scripts that redirect the standard output from one command and send it 
as standard input into another by separating those commands with a pipe.

We have used this method to string together several commands in order to generate a random password. We also then used a pipe to send that random password to the `passwd` command. 

---

# Different Types of Input and Output

Let's first look at the different types of input and output. There are three types of I/O (Input and Output):

* Standard Input
* Standard Output
* Standard Error 

---

By default, Standard Input comes from the keyboard. For example, the `read` command accepts standard input and you use the `read` command to collect information from a user typing something in using their keyboard.

However, Standard Input does not have to come from a keyboard. An example of this is using pipes to take the output generated by one command and use that as the standard input for another command.

---

Moving on to Standard Ouput and Standard Error, by default, both of these are displayed to the screen.

Let's start the script by redirecting the standard output of a command into a file, and you can do that by using the `>` symbol.

> NOTE: ou'll often see Standard Out abbreviated as stdout.

---

# Redirecting STDOUT to a file

![image](https://user-images.githubusercontent.com/107522496/211289085-5352e575-ee80-415c-99ab-a29b60026b9f.png)

`FILE="/tmp/data"`: We're going to be using a file several times throughout this script, so I'm just going to assign that file name to a variable.

We wil call that variable `FILE` and then I'm going to say that that file is going to live in  
`/tmp/data` and we'll call the name of that file `data`.

`head -n1 /etc/passwd > ${FILE}`: We'll use the `head` command, with `-n1` which will output the very first line of a file, to look at the `/etc/passwd` file and we will send the Standard Output of this command into `{FILE}`.

---

Remember, by default, Standard Output is displayed to the screen, but because we are using the `>` symbol after the command, it is redirecting that output away from the screen and into the file we specified after the greater than sign.

Now let's see what happens when we actually execute this script.

---

![image](https://user-images.githubusercontent.com/107522496/211290760-40843566-eebb-47d9-a4bc-008e0a0f635c.png)

To do this, save your changes and make the script executable.

---

![image](https://user-images.githubusercontent.com/107522496/211290834-c225dbde-c19e-499f-9004-48febf2013f3.png)

As we can see, no output was generated when we ran this script. This is because, instead of directing the output to the screen, we chose to redirect the output to a file. 

Let's take a look at that file using `cat` ...

![image](https://user-images.githubusercontent.com/107522496/211291828-7708910f-c130-46fd-8771-92f7b63b8a53.png)

`root:x:0:0:root:/root:/bin/bash` seems to be the output of `head -n1 /etc/passwd`. We can confirm this on the command line by using `head -n1 /etc/passwd` ... 

![image](https://user-images.githubusercontent.com/107522496/211292293-3cc7696c-db24-4c14-9b58-bd03025c5b9c.png)

---

To clarify, this output redirection is not part of any one command. It works with all commands. So, for example let's try this with the `ID` commmand. Let's type `id -un > id_file`.

![image](https://user-images.githubusercontent.com/107522496/211292862-63a05670-bd84-4fb5-b001-04f6ef6922c1.png)

Nothing is outputted when we run `id -un > id_file`. However, if we then use the `cat` command, we can see the contents of the `id_file` contains the output of `id -un > id_file`. 

---

![image](https://user-images.githubusercontent.com/107522496/211293303-63b62c8c-204b-4474-8d3f-9bde8b21e074.png)

This is another example. Let's use `echo`. If we get the uid_file, sure enough, the output of the `echo` command is in the file that we redirected that output to.

---

REMEMBER: file permissions play a part in redirection too. So, if you try to redirect output into a file where you don't have write permissions, you're going to get an error. For example: 

![image](https://user-images.githubusercontent.com/107522496/211293736-dca27bad-220e-4d0d-8642-58895a526885.png)

---

# Redirecting Standard Input

Now that we know that `>` redirects Standard Output. Nowlet's use the less than symbol,`<`, to redirect Standard Input.

> Standard Input is often abbreviated as stdin.

---

![image](https://user-images.githubusercontent.com/107522496/211297737-d35cc5e3-86ea-436c-bd94-d66864f749d3.png)

`read LINE < ${FILE}`: Here, we will use the `read` command. After the input redirection, we will supply a filename, in this case, we'll just use the same file that we created with the _head_ command.

---

Previously, we used the _read_ command to accept Standard Input from a user. By using input redirection, we are now accepting standard input from a file.

The _read_ command reads one line of standard input when someone is typing at the keyboard and they hit enter. That represents one line of standard input.

When dealing with files, a new line character will cause _read_ to stop, so the variable `LINE` should contain the first line of the file. In this example, there is only one line in the file.

`echo "LINE contains: ${LINE}"`: Let's prove that by echoing it to the screen, we'll say that the line variable contains the contents of the line variable here and hit enter.

Let's save changes and execute the script. 

---

![image](https://user-images.githubusercontent.com/107522496/211300634-d6e63710-2752-4206-ac50-c740387d23a0.png)

![image](https://user-images.githubusercontent.com/107522496/211300568-e9b94d93-1d91-4655-8f90-e247135b6485.png)

Here, we used output redirection to send the first line of the `/etc/passwd` file into a file named `/tmp/data`. That file was then used as Standard Input to the _read_ command, which assigned the value to the `LINE` variable.

Finally, the `LINE` variable was displayed to Standard Output using the _echo_ command and that gives you what you see on your screen here.

---
 
Redirecting Standard Input from a file works with any command that accepts standard input. For example, the _passwd_
command. 

![image](https://user-images.githubusercontent.com/107522496/211301527-f3e3bd19-56aa-43be-aba3-c4fbd80da991.png)

Here, I have echoed the word 'secret' to a filewhich I have named password. When using _cat_ to see the contents of the password file, we can see that indeed it does contain the word 'secret'.

Now let's use that file as standard input to the _passwd_ command. So we need root privileges to do this.

![image](https://user-images.githubusercontent.com/107522496/211302246-57c251b1-de01-4e0f-8153-cb956555fb73.png)

We're going to use _sudo passwd_ with a _--stndin_ option and we need to supply a user. Here, we have the Einstein user set up on this system. So we're going to use that user. Then we're going to redirect in the standard input that lives in the file password.


So we're going to redirect the contents of the file name password as standard input into the _passwd_ command. 

It says the passwords were changed for the user Einstein. I can verify this by just switching users using and I'm going to enter s e c r e t and hit enter and sure enough it accepts the password. So that works.

---

So, the first method we learnt was with a pipe, but now you know that we can also use this input redirection with the less than sign, `<`.

And remember, the difference between those methods is that in a pipe, the Standard Input comes from the output of a command, whereas with this less than symbol, `<`, the standard input comes from a file. So that's the difference.

In other words, a pipe is used when you want to take output from a command as input into another command. But you can use this redirection when you want to redirect the contents of a file into a command.

---

NOTE: using a single greater than sign, `>,` to perform redirection creates a new file if that file doesn't exist, or it overwrites the contents of that file if it does exist. For example ...

![image](https://user-images.githubusercontent.com/107522496/211304494-dd6cee54-4387-4de9-8a72-40389f168dec.png)

At the moment, the password file contains the word `secret`. If we perform a redirection to that file, it will get overridden.

![image](https://user-images.githubusercontent.com/107522496/211304732-25c00f19-f0d4-450d-b3f9-f898df6fffa7.png)

So, here we have echoed the word `Hello` to the password file. Now when we use _cat_ to see what is in the password file now, we can see that secret has been emoved and now it contains the word Hello.

Now let's demonstrate this in our script.

---

# Redirecting STDOUT to a file, overwriting the file.

![image](https://user-images.githubusercontent.com/107522496/211305496-910a7fb6-3067-4619-8175-3ff610e0f60c.png)

`head -n3 /etc/passwd > ${FILE}`: So now we're going to take the first three lines of the `/etc/passwd` file and send that into FILE.

`cat ${FILE}`: here, we are showing the contents of the file named FILE.

Now, let's save and execute the script.

---

![image](https://user-images.githubusercontent.com/107522496/211306133-af69dc7d-58ef-4e33-916b-ee61218e671e.png)

![image](https://user-images.githubusercontent.com/107522496/211306098-b22252f5-8d50-44af-a08b-b68e87601098.png)

The first time we performed a redirection to the script, we took the first line of the `/etc/passwd` file and put it into a file. The next time we performed redirection to that file, we took the first three lines of the `/etc/passwd` file and wrote it to that file.

So here you can see that the contents of `/tmp/data` contains three lines, not four lines. It didn't append to it, rather, it over wrote the contents of that file.

---

# Using `>>` to Append Data to a File 

what if you don't want to override a file, but you want to add or append to it? In this case, use `>>` symbols.

---

![image](https://user-images.githubusercontent.com/107522496/211320161-7a06cad7-2890-4050-8bd3-3f374ec5294b.png)

For example, let's take a look at the password file. It contains the word Hello.

Now let's add another line to the file. We'll do this, by writing `echo "World"` , and then we'll use two greater than symbols. And by the way, they can't have a space between them, rather, they should be together.

![image](https://user-images.githubusercontent.com/107522496/211320550-d751b8ab-0ad8-4c00-915f-b25130b7be7e.png)

Now we see both lines, the original one and the latest line we added to it. 

--- 

Let's keep adding to this file by using one of our password generation techniques.

![image](https://user-images.githubusercontent.com/107522496/211320966-8bcfae0b-d972-4c1a-b1d7-ea7767425c33.png)

Now the file contains that extra data.

So here we use pipes and output redirection. Let's add this as an example of IO redirection to our script.

---

# Redirecting STDOUT to a File, Appending to the File

![image](https://user-images.githubusercontent.com/107522496/211321236-1f43092a-5221-4320-8134-257b02572ae6.png)

Let's save our changes and execute the script.

---

![image](https://user-images.githubusercontent.com/107522496/211321587-9aa1e6e7-6699-4389-b6b1-54ea34be0d40.png)

So originally the contents of `/temp/data` was one line. It was overwritten by three lines, and then we performed an append output redirection. And so now it has five lines, you can see the random numbers that we generated and appended to the file.

---

# Code 

![image](https://user-images.githubusercontent.com/107522496/211323844-2847c48b-2992-49ce-9639-de10661246b5.png)

---


```bash
#!/bin/bash

# This script demonstrates I/O redirection.

# Redirect STDOUT to a file.
FILE="/tmp/data"
head -n1 /etc/passwd > ${FILE}

# Redirect STDIN to a program.
read LINE < ${FILE}
echo "LINE contains: ${LINE}"

# Redirect STDOUT to a file, overwriting the file.
head -n3 /etc/passwd > ${FILE}
echo
echo "Contents of ${FILE}:"
cat ${FILE}

# Redirect STDOUT to a file, appending to the file.
echo "${RANDOM} ${RANDOM}" >> ${FILE}
echo "${RANDOM} ${RANDOM}" >> ${FILE}
echo
echo "Contents of ${FILE}:"
cat ${FILE}

```


























