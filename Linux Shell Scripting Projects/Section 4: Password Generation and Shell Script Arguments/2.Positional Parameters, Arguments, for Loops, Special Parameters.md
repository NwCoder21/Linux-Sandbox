# Positional Parameters, Arguments, for Loops, Special Parameters

Will be learning about Positional Parameters and For Loops.

---

![image](https://user-images.githubusercontent.com/107522496/207848802-fb9f22ae-bd6d-48b1-b5d3-39bb13494e61.png)

Will create a script called lusers-demo06.sh

---

# `#!/bin/bash`

![image](https://user-images.githubusercontent.com/107522496/207849081-3c6a85d7-4691-4d6f-8441-9f110969d3b0.png)

As always, we need to start each script with a shebang (`#!/bin/bash`).

Have also included the objective of this script.

---

# Display what the user typed on the command line

![image](https://user-images.githubusercontent.com/107522496/207850370-ca86c573-eb76-43a7-be08-eda57f663c56.png)

The variable `${0}` is actually a positional parameter, and positional parameters are variables that contain the contents of the command line.

---

# Difference between an argument and positional parameter 

A parameter is a variable that is being used inside the shell script. An argument is the data passed into the shell script. So an argument which is supplied on the command line, becomes the value stored in a parameter.

With this in mind, the very first positional parameter is `${0}`, which contains the name of the script itseWe lf. We can think of this as being what the person typed in the command line to execute the script.

The next positional parameter is `${1}`, which stores the value of the first argument passed to the script when running it on the command line.

The positional parameter `${2}` stores the second argument. `${3}` stores the third argument and so on.

--- 

![image](https://user-images.githubusercontent.com/107522496/207851599-2b8e4916-0a77-4f37-8a29-95683cdc4e77.png)

Now let's look at the output of our script so far: 

![image](https://user-images.githubusercontent.com/107522496/207851864-21b3b7fc-21e5-44e0-b89f-b0c53b44c3d9.png)

When we run this script, `${0}` expands to how we executed the script, `/home/tuser/myscripts/lusers-demo06.sh`.

---

<!-- 3:27 -->

# `PATH` variable 

The command search path is stored in the environment variable `PATH`.

![image](https://user-images.githubusercontent.com/107522496/207852800-476cee9e-ec63-451e-afaa-72ae274b8fef.png)

If a command is not a function or a shell built in, then Bash will look for that command first in the above folders, in the sam order they are listed. 

`PATH` can be changed so no guarantee that it will be the same for every user across every system.

If you want to control the path, you can do so in your script by manipulating the `${path}` variable there.

---

![image](https://user-images.githubusercontent.com/107522496/207853645-a70b6daa-d957-4937-9851-2a15f4cb34d9.png)

To see what command will be executed, we can use the `which` command. For example, in the above screenshot, we are checking what command will be executed when we run `head`. In this case, it is `/usr/bin/head`.

<!-- Go over from 3:27 till 8:47  -->

---

# `basname` 

The `basename` command removes the directory component and just returns the file name. Let's check its man page:

![image](https://user-images.githubusercontent.com/107522496/207855111-89031af3-1530-4571-807e-dd3e724db316.png)

We can see that: "basename - strip directory and suffix from filenames"

---

![image](https://user-images.githubusercontent.com/107522496/207856930-20027f2c-48ce-4d2b-b671-8ee2dff47532.png)

Now when we run our script, it only outputs the file/script we are running and not the whole path.

---

`basename` does not do any smart checking to see if the file exists. It just strips off the directory portion of a string that is passed to it so, we can even give a `basename` something that clearly doesn't exist, but it will still do its job. For example: 

![image](https://user-images.githubusercontent.com/107522496/207857364-4064242a-9c16-4267-86d2-af687f2adb25.png)

We an prove that this file does not exist by using ls /directory/file. When run, it says no such file or directory.

---

# `dirname`

This is the opposite of `basename`. This takes off the last component from a file name:

![image](https://user-images.githubusercontent.com/107522496/207857720-945e48f0-d8cb-4fa8-b11f-5e736c39d5f8.png)

---

![image](https://user-images.githubusercontent.com/107522496/207858308-d607e40b-46b7-4753-87b8-df4006aca09f.png)

From this we can see that `dirname` strips off the file name and only outputs the rest of the path.

---

Like `basename`, `dirname` does not do any smart checking. We can give it a non existent path and it will simply return the portion that looks like the directory. For example: 

![image](https://user-images.githubusercontent.com/107522496/207858783-ac56581f-8898-413f-9ca3-31401cafd3bc.png)

This whole path does not exist, but `dirname` doesn't check, rather, it just returns the directory of the file.

---

Now let's use both of these commands in our script.

---

# Display the path and filename of the script

![image](https://user-images.githubusercontent.com/107522496/207859598-c9633283-98e0-4ff0-8123-28183df7201e.png)

In previous lessons,we used a `$` followed by a command that was wrapped in parentheses to assign the output of that command to a variable that is called **command substitution**. For example:

```bash
# Display Username
USERNAME=$(id -un)
```

In this case, we are only going to use the output of each of these commands once, so we just included them right in the echo command.

Again, what this `$(<command>)` syntax does or this **command substitution** syntax does, is return the output of the command. You can assign the output to a variable or use that output without assigning it to a variable. Either way is fine.

You don't have to use **command substitution ** and **variable assignment** only you can use it in line as well.

---
Now let's run our script:

![image](https://user-images.githubusercontent.com/107522496/207874632-dbcf9f87-e9e9-44e2-a07a-5da8e69a7c26.png)

---

![image](https://user-images.githubusercontent.com/107522496/207874501-d7157990-8f46-4d3e-8f47-fa5c1016af1f.png)

This is what we get. The first output displays the path and the actual file name itself, whereas the second output displays the path separately (using `dirname`), and the file separately (using `basename`).

---

# Special Parameter

Let's take a look at the man page for bash, `man bash` and search for `/Special Parameter`

![image](https://user-images.githubusercontent.com/107522496/207881890-5279297d-0200-4c33-a8cc-a858caa95fab.png)

For `#` we can se that it says `$#` tells us how many arguments were supplied on the command line.

---

# Tell the user how many arguments they passed in.

Back to our script: 

![image](https://user-images.githubusercontent.com/107522496/207882645-d3947e85-26af-4044-b6a6-71fdb6408e35.png)

Remember, we can use either `NUM_OF_PARAMETERS="$#"` or `NUM_OF_PARAMETERS="${#}"`. Don't have to use `{}`.

Let's save changes and run script.

---

![image](https://user-images.githubusercontent.com/107522496/207883942-5a710fa5-07af-42dd-acdc-cf3c65b51bd2.png)

It says we have provided 0 arguments. Let's provide it with an argument:

![image](https://user-images.githubusercontent.com/107522496/207884280-9f82da67-9cad-4279-a9d5-4eff2ed89442.png)

We can see that it accurately tells us the amount of arguments we provided. This means the `$#` must be working. 

---

# Make sure that user supplies at least one argument.

The aim of this script is to generate a random password for each user that supplied on the command line. So, We want to make sure that at least one user is supplied on the command line.

![image](https://user-images.githubusercontent.com/107522496/207889167-9cab1188-3511-4d79-b5c2-58819fba3b69.png)

`"${NUM_OF_PARAMETERS}"`: When we use a variable in between brackets here, we're going to enclose it in quotation marks.

`echo "Usage: ${0} USER_NAME [USER_NAME]..."`: So if the number of parameters is less than one, then what we're going to do is echo a usage statement. Instead of manually typing in the name of the script, we can just simply use dollar sign zero to echo back more or less what the user typed in at the command line, and then we'll tell them what they need to do. They need to supply a username (`USER_NAME`) and optionally they can supply another username (`[USER_NAME]`) and actually optionally they can supply even more username (`...`).

`exit 1`: If user reaches this point, it means that the script did not successfully execute because they didn't give us any people to create passwords for. So, what we're going to do is exit with the non zero exit 

> Note: could also have said if the number of parameters equals zero, then give them the usage statement and exit.


Continue from 20:10






