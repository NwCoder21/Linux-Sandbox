# Positional Parameters, Arguments, for Loops, Special Parameter 

This lessons continues with positional parameters, and will also cover how to create a while loop.

---

![image](https://user-images.githubusercontent.com/107522496/209114874-a3db81cf-4e17-4f31-b679-8378994017b3.png)

Will name this script `luser-demo06.sh` 

---

![image](https://user-images.githubusercontent.com/107522496/209115337-dc2ea4fe-853d-4468-bbea-77376fb23bb0.png)

Will then start the bash script with the shebang (`#!/bin/bash`) and write  a comment outlining the purpose of this script.

---

# Display the first three parameters 

In the last lesson, we learnt that the first positional parameter of `${0}` contains the name of the script itself, while `${1}` stores the value of the first argument pass to the script on the command line. `${2}` stores the second argument and so on.

We never actually used `${1}` and onwards directly in that lesson, so let's do that now and see how they work and how they behave in different situations. 

---

![image](https://user-images.githubusercontent.com/107522496/209116329-2db7c777-4a32-4cb9-a723-3889e82b05fe.png)

The last `echo` statement will print a blank line. 

---

![image](https://user-images.githubusercontent.com/107522496/209116550-dc245bab-6259-425e-bcd5-eb5eecfe3e54.png)

Save the script and grant it executable permissions.

---

![image](https://user-images.githubusercontent.com/107522496/209119264-bef099d6-a736-47ba-816d-b4772f3a231e.png)

Here, have run the script with no arguments, this means there are no values to store inside the script as positional parameters with the exception of `${0}`. This is the very first positional parameter and contains the name of the script itself. 

---

![image](https://user-images.githubusercontent.com/107522496/209119955-991413a0-8fab-4cb9-85a5-673e2402e5b6.png)

Now we have passed in a parameter 'pear'. This means `${1}` is assigned the value of `pear`.

---

![image](https://user-images.githubusercontent.com/107522496/209122043-c71ae226-25b3-4eed-b76a-ce96659caaa2.png)

So this is how we access the arguements within the script, i.e, by using postional parameters.   

---

![image](https://user-images.githubusercontent.com/107522496/209122837-fc52ac1e-6d8f-4a3e-b15f-67de844843d8.png)

If we were to add more command line arguments, for example, another word here, let's say 'newspaper', then that is stored in `${4}` but we didn't account for a user entering `${4}`. This can present an issue because we don't know exactly how many arguments a user may input. This is why use for loops and while loops to handle command line arguments.

---

Next in our script we want to loop through all the positional parameters. In the previous lesson, we used a For Loop to do that, but this time we will use a While Loop.
 
 ---
 
 ![image](https://user-images.githubusercontent.com/107522496/209124707-115f62a4-bd69-420a-b1d4-418942e01874.png)

So, first, let's take a look what type a While Loop is using `type -a while`. We can see that it is a shell keyword/shell built-in. This means we can use `help` against this command for more information on it. Type `help while`.

---

![image](https://user-images.githubusercontent.com/107522496/209125541-5c48fada-a1f7-45e9-a265-c9d607098c45.png)

`"Execute commands as long as a test succeeds.

Expand and execute COMMANDS as long as the final command in the `while` COMMANDS has an exit status of zero."`: 

You can think of this as being `while true, Do.` in other words, while the condition that is being tested for is true, then the commands will execute.

This means that during the while loop, we will want to change the thing being tested for in some way so that the condition eventually evaluates to false. Otherwise, we will end up endin an infinite loop.

---

Now let's create a While Loop on the command line...

![image](https://user-images.githubusercontent.com/107522496/209128297-8e09ee40-aef4-401a-8c01-3428fe5410f1.png)

Here, we are using a variable called `X` and will assign it a value of 1. 

`"${X}" -eq 1` is a conditional expression and we are testing to see if `${X}` is equal to one.

If this is true, then we will `echo "The value of X is: ${X}"`
`X=5` here, we are manipulating the value of X so this does not becomen infinite loop. 


So, thw while loop runs and checks if X is equal to 1. If this is true, and it is on the first loop, it then prints out the echo statement. X is then changed to 5. The While Loop runs again and checks if X is equal to 1. This time this is false, so the While Loop does not run the echo statement again and the While Loop exits.

This While Loop demonstrates changing a variable that is being tested against in the conditional expression of the while loop.

If the conditional expression never evaluates to true, then the commands in the While Loop will never get executed.

---

Let's create an infinite loop and see how we can break out of it, but first, let's introduce the `true` command. Its only job is to return an exit status of true. 
  
---

# `true`

![image](https://user-images.githubusercontent.com/107522496/209134500-667f1993-c20d-4b69-884c-a07b98656c0a.png)

`true` is a shell built-in as well as a program. Can get more information on a built-in using `help`.

---

![image](https://user-images.githubusercontent.com/107522496/209134715-dd96a069-0bee-4312-b9b7-3d201a724f49.png)

it says it just returns a successful result. The exit status is that it always succeeds. Becuase `true` is also a program, let's use `man` formore information.

---

![image](https://user-images.githubusercontent.com/107522496/209134923-56743706-4ced-493d-b8ba-4d133bbed37c.png)

It says "true - do nothing, successfully". No matter what happens with true, it just returns an exit status of zero. Let's test this out.

---

![image](https://user-images.githubusercontent.com/107522496/209135202-12762838-f1a9-47bc-9b28-6d96907dbe8c.png)

It always returns 0. 

---

# `sleep`

Before we create our infinite loop, let's look at just one more command called `sleep`.

![image](https://user-images.githubusercontent.com/107522496/209135482-57b472ef-3a77-49a0-bad0-8c1814e22998.png)

`sleep` happens to be an executable program on the system. It's not a shell built-in, so we'll use the `man` page to learn more about `sleep`.

---

![image](https://user-images.githubusercontent.com/107522496/209135677-3a60f728-e6d9-4a41-a5ac-3bd75ecf067e.png)

So `sleep` simply delays execution for a specified amount of time.

You can use `sleep` followed by a number and a suffix, and that suffix can be `s` for seconds, or `m` for minutes,
or `h` for hours, or `d` for days.

So when the `sleep` command is run, the system doesn't do anything for a specific amount of time.

---

![image](https://user-images.githubusercontent.com/107522496/209137534-b1f88397-b80d-4c07-9ba8-e19a85a00967.png)

1 and 1s is the same, it means one second. .5 means half a second.

---

# Infinite Loop

Now let's build our infinite loop..

![image](https://user-images.githubusercontent.com/107522496/209138629-5b619d1f-69a4-41ea-9bf5-24f96607b0dd.png)

Here, we are testing for true. `true` always returns an exit status of 0. So it's always true. So this is going to never change. This while loop is going to run forever.

`done`: this is how to close out the while loop. 

This loop will continue to run forever. To break out of this loop, hold down the `CTRL` and type `c`, this sends an interrupt signal to the command, which makes it stop.

Now, this isn't something unique to the while command. You can use this to stop any command running in the foreground.
For example, if you execute the `sleep` command and want to interrupt it and return to the command line sooner, you can use `CTRL` + `c `there as well.

---

![image](https://user-images.githubusercontent.com/107522496/209139627-e4343b7f-7cd5-4928-b303-6d150579ee89.png)

Let's say we run the `sleep` command and tell it to sleep for 10 minutes. But then we decide we don't want to wait that long.
So, can hold down the `CTRL` and type `c`, and it will break out of that command. 

![image](https://user-images.githubusercontent.com/107522496/209139931-c37842dc-bfa8-4234-bd94-1a9c8218d211.png)

`^C` shows that a command was interrupted.

---

We will cover one more thing before we before we use a while loop in our script to loop over all the positional parameters.

This last thing to cover is `shift`.

---

# `shift`

![image](https://user-images.githubusercontent.com/107522496/209140389-2b0b0182-eb92-46d4-86b7-50d0a11ce58e.png)

We can see that `shift` is a shell built-in.

![image](https://user-images.githubusercontent.com/107522496/209151594-52175d59-82be-49e9-836c-46780da55e08.png)

Now, what the shift command really does is that it removes positional parameters from the list, starting with `$1`. So, when you execute the shift command, the value stored in `$1` is removed. 

What also happens is that the value stored in `$2` shifts down to `$1`,  the value in `$3` moves down to `$2`, the value in `$4` moves down and replaces the value in `$3` and so on and so forth.

Also, the special parameter of `$#` is reduced by one. As mentioned in the previous lesson, a `$#` contains the number of arguments that were supplied on the command line.

By default, the `shift` command shifts everything one place.

Executing `shift` by itself is the same thing as executing `shift 1`. If you want to shift everything by two places, use `shift 2`. In that case, `$#` be decreased by two.

If you want to shift everything by three positions, you `shift 3` and so on.

---

Now let's use `shift` in our script.

---

Now we will loop through all the positional parameters...


































